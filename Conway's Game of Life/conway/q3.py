import conway.world as world


# Answer the Part 3a questions here:
#
# The list of rows were generated by using splitlines which checks for line breaks before putting it into a list
# world [0] represents the first row of the world list variable (inner lists)
# world represents the column (outer list) which if imagined in 2d is the height
# Lengths were multiplied by cell_size variable inside config module to emulate a box/cell
#
# x += config.cell_size is to move onto the next row.
# y += config.cell_size is to move onto the next column.
# The moves creates enough space for the next box/cell to be drawn.
#
# evolve_func is itself a function in this case
# init function takes evolve_func as one of its argument
# because of this, init is a high order function
# window.after(config.frame_length, do_next_frame)
# .after seems to be a (method?) and it's taking do_next_frame, a function, as an argument
# it seems like this is sort of a high order function
def get_world():
  """Returns a non-ragged 2d list representing the starting state of
     a game of Conway's Game of Life
     The individual elements are one of:
     - '.' (an empty space), or 
     - '*' (a live cell)
  """
  # Start with the world string from the world module
  world_str = world.get_world_str()
  return [list(line) for line in world_str.splitlines()]


def count_live_neighbours(world, x, y):
  """Returns the number of live neighbours of the cell at (x, y) 
    in the given world.
    
    world must be a non-ragged 2d list of . or * characters
    (* represents a live cell)
    x and y must be integers that are valid indices of world
  """
  # Calculate the width and height of the world
  height = len(world)
  width = len(world[0])
  live_neighbor_count = 0
  neighbor_coordinates = [
      [-1, -1],
      [-1, 0],
      [-1, 1],
      [0, -1],
      [0, 1],
      [1, -1],
      [1, 0],
      [1, 1],
  ]
  for i, j in neighbor_coordinates:  #traverse the list coordinates
    neighbor_x, neighbor_y = i + x, j + y  # coordinates of neighbors to use as index for world
    # To check if still within the world boundaries
    if (neighbor_x >= 0 and neighbor_x < width) and (
        neighbor_y >= 0
        and neighbor_y < height) and world[neighbor_y][neighbor_x] == "*":
      live_neighbor_count += 1
  return live_neighbor_count

  # for i in range(-1, 2):
  #   for j in range(-1, 2):
  #     if i == 0 and j == 0: # to skip itself
  #       continue
  #     nx = x + i
  #     ny = y + j
  #     if 0 <= nx < width and 0 <= ny < height: #checks if it's out of bounds
  #       if world[ny][nx] == '*':
  #           live_neighbor_count += 1
  # return live_neighbor_count


def evolve(world):
  """Returns the next state of the world given the current state,
    according to the rules of Conway's Game of Life.
    world must be a non-ragged 2d list of . or * characters.

    Rules:
    1. Underpopulation: 
          Any live cell (*) with fewer than 2 live neighbours dies (.)
    2. Stable: 
          Any live cell (*) with 2 or 3 live neighbours lives (*)
    3. Overpopulation: 
          Any live cell (*) with more than 3 live neighbours dies (.)
    4. Reproduction: 
          Any dead cell (.) with 3 live neighbours becomes a live cell (*)
    """
  new_world = []
  for y in range(len(world)):  # To traverse rows
    new_row = []
    for x in range(len(world[0])):  # To traverse columns
      live_neighbors = count_live_neighbours(
          world, x, y)  #check how many live neighbor for current cell
      if world[y][x] == '*':  #rules for live cell
        if live_neighbors < 2 or live_neighbors > 3:
          new_row.append('.')
        else:
          new_row.append('*')
      else:  #Rules for a dead cell
        if live_neighbors == 3:
          new_row.append('*')
        else:
          new_row.append('.')
    new_world.append(new_row)  # add the new row to the new world
  return new_world  #return the new world for the next frame (evolved world)
